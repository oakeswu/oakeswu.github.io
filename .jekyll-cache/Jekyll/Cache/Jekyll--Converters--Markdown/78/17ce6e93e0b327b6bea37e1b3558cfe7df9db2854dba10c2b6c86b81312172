I"ò<p>#å‰æ
è¯´åˆ°SynchronousQueueï¼ŒLinkedBlockingQueue ï¼ŒArrayBlockingQueueå°±ä¸å¾—ä¸å…ˆæä¸€ä¸‹BlockingQueueè¿™ä¸ªæ¥å£ï¼Œæˆ‘ä»¬å…ˆçœ‹ä¸‹BlockingQueueçš„å…³ç³»å›¾
<img src="https://upload-images.jianshu.io/upload_images/9082703-629424f133ab4d9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" />
ç„¶åBlockingQueueæœ‰å‡ ä¸ªæ–¹æ³•å¿…é¡»è¯´ä¸€ä¸‹ï¼š
<img src="https://upload-images.jianshu.io/upload_images/9082703-2f6ecfaf83e22059.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" />
æˆ‘ä»¬çœ‹putå’Œtakeå°±èƒ½çŸ¥é“ä¸ºå•¥å«é˜»å¡ï¼ˆBlockingï¼‰é˜Ÿåˆ—äº†ï¼Œå°±æ˜¯å› ä¸ºåœ¨åŸå§‹QueueåŠ ä¸Šäº†ä¼šé˜»å¡ç­‰å¾…çš„putå’Œtakeæ–¹æ³•ã€‚</p>

<h1 id="ä¸‰è€…å¼‚åŒ">ä¸‰è€…å¼‚åŒ</h1>
<ul>
  <li>SynchronousQueueæœ¬èº«æ²¡æœ‰å®¹é‡å­˜å‚¨å…ƒç´ ï¼Œæ˜¯é€šè¿‡ç®¡ç†æäº¤æ“ä½œçš„çº¿ç¨‹é˜Ÿåˆ—æ¥å®ç°é˜»å¡é˜Ÿåˆ—çš„ã€‚ArrayBlockingQueueæ˜¯é€šè¿‡æ•°ç»„æ¥å­˜å‚¨å…ƒç´ çš„é˜Ÿåˆ—ï¼Œå¹¶ä¸”é‡Œé¢é€šè¿‡ä¸€ä¸ªReetrantLockå’ŒConditionå®ç°çº¿ç¨‹å®‰å…¨ã€‚LinkedBlockingQueue æ˜¯é€šè¿‡é“¾è¡¨æ¥å­˜å‚¨å…ƒç´ çš„é˜Ÿåˆ—ï¼Œä¹Ÿæ˜¯é€šè¿‡ReetrantLockå’ŒConditionå®ç°çš„çº¿ç¨‹å®‰å…¨ï¼Œä½†æ˜¯å…¥é˜Ÿå’Œå‡ºé˜Ÿç”¨çš„æ˜¯ä¸¤ä¸ªä¸åŒçš„ReetrantLocké”ã€‚</li>
  <li>SynchronousQueueæœ€å¤šå°±æ˜¯çº¿ç¨‹å…¥é˜Ÿçš„ä¸€ä¸ªæ•°æ®ï¼ŒArrayBlockingQueueæ„é€ å‡½æ•°å¿…é¡»ç½®é¡¶åˆå§‹åŒ–æ•°ç»„å®¹é‡å¤§å°ï¼Œæ‰€ä»¥æ˜¯ä¸€ä¸ªæœ‰ç•Œé˜Ÿåˆ—ï¼ŒLinkedBlockingQueueæ„é€ å‡½æ•°å¯ä»¥æŒ‡å®šåˆå§‹åŒ–å®¹é‡å¤§å°ï¼Œå¦‚æœä¸æŒ‡å®šå°±æ˜¯Integer.MaxValueçš„æœ‰ç•Œé˜Ÿåˆ—
æˆ‘ä»¬ä¸»è¦åˆ†æä¸‹ArrayBlockingQueueçš„æºç </li>
</ul>

<h1 id="arrayblockingqueueæºç ç²¾ç®€ç‰ˆ">ArrayBlockingQueueæºç ç²¾ç®€ç‰ˆ</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, Serializable {
    //å­˜å‚¨å…ƒç´ ç”¨çš„æ•°ç»„
    final Object[] items;
    //é˜Ÿé¦–å…ƒç´ çš„ä¸‹æ ‡
    int takeIndex;
    //é˜Ÿå°¾å…ƒç´ çš„ä¸‹æ ‡
    int putIndex;
    //é˜Ÿåˆ—çš„å…ƒç´ ä¸ªæ•°
    int count;
    //é€šè¿‡ReentrantLockæ¥å®ç°çº¿ç¨‹å®‰å…¨
    final ReentrantLock lock;
    private final Condition notEmpty;
    private final Condition notFull;
    
    //é»˜è®¤çš„æ„é€ å‡½æ•°å¿…é¡»ä¼ å…¥é˜Ÿåˆ—å¤§å°ï¼Œæ‰€ä»¥æ˜¯æœ‰ç•Œé˜Ÿåˆ—ï¼Œå¯ä»¥æŒ‡å®šæ˜¯å¦é‡‡ç”¨å…¬å¹³é”
    public ArrayBlockingQueue(int capacity) {
        this(capacity, false);
    }
    public ArrayBlockingQueue(int capacity, boolean fair) {
        if (capacity &lt;= 0)
            throw new IllegalArgumentException();
        this.items = new Object[capacity];
        lock = new ReentrantLock(fair);
        notEmpty = lock.newCondition();
        notFull =  lock.newCondition();
    }
    
    //offeræ–¹æ³•æ·»åŠ æ•°æ®ï¼Œä¸ä¼šé˜»å¡çº¿ç¨‹
    public boolean offer(E e) {
        Objects.requireNonNull(e);
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            //å¦‚æœé˜Ÿåˆ—å·²ç»æ»¡äº†çš„è¯ç›´æ¥å°±è¿”å›false
            if (count == items.length)
                return false;
            else {
                //å¦‚æœé˜Ÿåˆ—æ²¡æœ‰æ»¡ï¼Œå°±è°ƒç”¨enqueueæ–¹æ³•å°†å…ƒç´ æ·»åŠ åˆ°é˜Ÿåˆ—ä¸­
                enqueue(e);
                return true;
            }
        } finally {
            lock.unlock();
        }
    }
    
    //å¢åŠ ä¸€ä¸ªç­‰å¾…æ—¶é—´çš„offeræ–¹æ³•
    public boolean offer(E e, long timeout, TimeUnit unit)
        throws InterruptedException {

        Objects.requireNonNull(e);
        long nanos = unit.toNanos(timeout);
        final ReentrantLock lock = this.lock;
        //è·å–å¯ä¸­æ–­é”
        lock.lockInterruptibly();
        try {
            while (count == items.length) {
                //å¦‚æœç­‰å¾…æ—¶é—´è¿‡äº†é˜Ÿåˆ—è¿˜æ˜¯æ»¡çš„è¯å°±ç›´æ¥è¿”å›falseï¼Œæ·»åŠ å…ƒç´ å¤±è´¥
                if (nanos &lt;= 0L)
                    return false;
                //ç­‰å¾…è®¾ç½®çš„æ—¶é—´
                nanos = notFull.awaitNanos(nanos);
            }
            //å¦‚æœç­‰å¾…æ—¶é—´è¿‡äº†ï¼Œé˜Ÿåˆ—æœ‰ç©ºé—´çš„è¯å°±ä¼šè°ƒç”¨enqueueæ–¹æ³•å°†å…ƒç´ æ·»åŠ åˆ°é˜Ÿåˆ—
            enqueue(e);
            return true;
        } finally {
            lock.unlock();
        }
    }
    
    //putæ–¹æ³•å’Œofferæ–¹æ³•ä¸ä¸€æ ·çš„åœ°æ–¹åœ¨äºï¼Œå¦‚æœé˜Ÿåˆ—æ˜¯æ»¡çš„è¯ï¼Œå®ƒå°±ä¼šæŠŠè°ƒç”¨putæ–¹æ³•çš„çº¿ç¨‹é˜»å¡ï¼Œç›´åˆ°é˜Ÿåˆ—é‡Œæœ‰ç©ºé—´
    public void put(E e) throws InterruptedException {
        Objects.requireNonNull(e);
        final ReentrantLock lock = this.lock;
        
        lock.lockInterruptibly();
        try {
            while (count == items.length)
                //å¦‚æœé˜Ÿåˆ—æ»¡çš„è¯å°±é˜»å¡ç­‰å¾…
                notFull.await();
            enqueue(e);
        } finally {
            lock.unlock();
        }
    }
    
    //pollæ–¹æ³•ç”¨äºä»é˜Ÿåˆ—ä¸­å–æ•°æ®ï¼Œä¸ä¼šé˜»å¡çº¿ç¨‹
    public E poll() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            //è¿™é‡Œå¯ä»¥çœ‹åˆ°å¦‚æœé˜Ÿåˆ—ä¸ºç©ºçš„è¯ä¼šç›´æ¥è¿”å›nullï¼Œå¦åˆ™è°ƒç”¨dequeueæ–¹æ³•å–æ•°æ®
            return (count == 0) ? null : dequeue();
        } finally {
            lock.unlock();
        }
    }
    
    //å¢åŠ ç­‰å¾…æ—¶é—´çš„pollæ–¹æ³•ï¼Œå’Œä¸Šé¢offerçš„é‡è½½ç±»ä¼¼
    public E poll(long timeout, TimeUnit unit) throws InterruptedException {
        long nanos = unit.toNanos(timeout);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == 0) {
                if (nanos &lt;= 0L)
                    return null;
                nanos = notEmpty.awaitNanos(nanos);
            }
            return dequeue();
        } finally {
            lock.unlock();
        }
    }
    
    //takeæ–¹æ³•ä¹Ÿæ˜¯ç”¨äºå–é˜Ÿåˆ—ä¸­çš„æ•°æ®ï¼Œå¯èƒ½ä¼šé˜»å¡å½“å‰çš„çº¿ç¨‹
    public E take() throws InterruptedException {
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            //å½“é˜Ÿåˆ—ä¸ºç©ºæ—¶ï¼Œå°±ä¼šé˜»å¡å½“å‰çº¿ç¨‹
            while (count == 0)
                notEmpty.await();
            //ç›´åˆ°é˜Ÿåˆ—ä¸­æœ‰æ•°æ®äº†ï¼Œè°ƒç”¨dequeueæ–¹æ³•å°†æ•°æ®è¿”å›
            return dequeue();
        } finally {
            lock.unlock();
        }
    }
    
    //å°†æ•°æ®æ·»åŠ åˆ°é˜Ÿåˆ—ä¸­
    private void enqueue(E x) {
        // assert lock.getHoldCount() == 1;
        // assert items[putIndex] == null;
        final Object[] items = this.items;
        items[putIndex] = x;
        //å¯ä»¥çœ‹å‡ºæ˜¯é€šè¿‡å¾ªç¯æ•°ç»„å®ç°çš„é˜Ÿåˆ—ï¼Œå½“æ•°ç»„æ»¡äº†æ—¶ä¸‹æ ‡å°±å˜æˆ0äº†
        if (++putIndex == items.length) putIndex = 0;
        count++;
        //æ¿€æ´»å› ä¸ºnotEmptyæ¡ä»¶è€Œé˜»å¡çš„çº¿ç¨‹ï¼Œæ¯”å¦‚ä¸Šé¢çš„è°ƒç”¨takeæ–¹æ³•çš„çº¿ç¨‹
        notEmpty.signal();
    }

    //å°†æ•°æ®ä»é˜Ÿåˆ—ä¸­å–å‡º
    private E dequeue() {
        // assert lock.getHoldCount() == 1;
        // assert items[takeIndex] != null;
        final Object[] items = this.items;
        @SuppressWarnings("unchecked")
        E x = (E) items[takeIndex];
        //å°†å¯¹åº”çš„æ•°ç»„ä¸‹æ ‡ä½ç½®è®¾ç½®ä¸ºnullé‡Šæ”¾èµ„æº
        items[takeIndex] = null;
        if (++takeIndex == items.length) takeIndex = 0;
        count--;
        if (itrs != null)
            itrs.elementDequeued();
        //æ¿€æ´»å› ä¸ºnotFullæ¡ä»¶è€Œé˜»å¡çš„çº¿ç¨‹ï¼Œæ¯”å¦‚ä¸Šé¢çš„è°ƒç”¨putæ–¹æ³•çš„çº¿ç¨‹
        notFull.signal();
        return x;
    }
    
    //è·å–é˜Ÿåˆ—çš„å…ƒç´ ä¸ªæ•°ï¼ŒåŠ äº†é”ï¼Œæ‰€ä»¥ç»“æœæ˜¯å‡†ç¡®çš„
    public int size() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return count;
        } finally {
            lock.unlock();
        }
    }
}
</code></pre></div></div>
<p>ä¸Šé¢å°±æ˜¯ArrayBlockingQueueçš„ç²¾ç®€ç‰ˆæºç åˆ†æï¼ŒLinkedBlockingQueueåŸç†ä¹Ÿç±»ä¼¼ï¼Œä¸è¿‡è¿˜æ˜¯æœ‰åŒºåˆ«ï¼Œè­¬å¦‚ç”¨äº†ä¸¤ä¸ªé”ï¼Œç”¨äº†é“¾è¡¨å­˜å‚¨æ•°æ®è€Œä¸æ˜¯æ•°ç»„ï¼ŒSynchronousQueueæºç å·®åˆ«ä¼šæ›´å¤§ä¸€ç‚¹ï¼Œæœ‰æ—¶é—´å¯ä»¥å†ä»”ç»†çœ‹çœ‹</p>
:ET