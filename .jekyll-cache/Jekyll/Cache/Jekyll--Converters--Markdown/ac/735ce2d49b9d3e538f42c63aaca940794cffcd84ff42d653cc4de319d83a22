I"ñ<h1 id="èƒŒæ™¯">èƒŒæ™¯</h1>
<p>ä¹‹å‰å­¦ä¹ äº†AQSæºç ï¼Œç°åœ¨å°±å¯ä»¥å¥½å¥½å­¦ä¹ ä¸‹AQSçš„ä¸€ä¸ªåº”ç”¨ReentrantLockã€‚ReentrantLockè·Ÿsynchronizedä¸€æ ·æ˜¯ä¸€ä¸ªå¯é‡å…¥é”ï¼Œä½†æ˜¯ReentrantLockå¯ä»¥å®ç°å…¬å¹³å’Œéå…¬å¹³é”ï¼Œè€Œsynchronizedåªæ˜¯éå…¬å¹³é”ï¼Œæ‰€ä»¥æˆ‘ä»¬ç°åœ¨å°±æ¥çœ‹ä¸‹ReentrantLockçš„æºç </p>

<h1 id="æºç ">æºç </h1>
<ul>
  <li>å®ç°Lockæ¥å£
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class ReentrantLock implements Lock, java.io.Serializable {
  private final Sync sync;
  //å–é”ï¼Œè·å–ä¸åˆ°è¿›å…¥ç­‰å¾…é˜Ÿåˆ—
  public void lock() {
      sync.lock();
  }
  //å“åº”ä¸­æ–­çš„è·å–é”
  public void lockInterruptibly() throws InterruptedException {
      sync.acquireInterruptibly(1);
  }
  //è·å–é”ï¼Œè·å–ä¸åˆ°å°±ç›´æ¥è¿”å›falseï¼Œå› ä¸ºnonfairTryAcquireæ˜¯ä¹Ÿæ˜¯lockä¸­ä¸€ä¸ªä¸­é—´æ­¥éª¤
  public boolean tryLock() {
      return sync.nonfairTryAcquire(1);
  }

  public boolean tryLock(long timeout, TimeUnit unit)
          throws InterruptedException {
      return sync.tryAcquireNanos(1, unit.toNanos(timeout));
  }
  //é‡Šæ”¾é”
  public void unlock() {
      sync.release(1);
  }
  
  public Condition newCondition() {
      return sync.newCondition();
  }
  //é»˜è®¤æ˜¯éå…¬å¹³é”
  public ReentrantLock() {
      sync = new NonfairSync();
  }
    
  public ReentrantLock(boolean fair) {
      sync = fair ? new FairSync() : new NonfairSync();
  }
</code></pre></div>    </div>
    <p>æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä¸Šé¢å®ç°Lockæ¥å£çš„æ–¹æ³•æœ€ç»ˆéƒ½æ˜¯æ“ä½œä¸€ä¸ªSyncå¯¹è±¡ï¼Œæˆ‘ä»¬å°±æ¥çœ‹ä¸‹syncæ˜¯å•¥ï¼Ÿ</p>
  </li>
  <li>Sync
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>abstract static class Sync extends AbstractQueuedSynchronizer {
  private static final long serialVersionUID = -5179523762034025860L;

  abstract void lock();

  //éå…¬å¹³çš„è·å–é”
  final boolean nonfairTryAcquire(int acquires) {
      final Thread current = Thread.currentThread();
      int c = getState();
      if (c == 0) {
          if (compareAndSetState(0, acquires)) {
              setExclusiveOwnerThread(current);
              return true;
          }
      }
      else if (current == getExclusiveOwnerThread()) {
          int nextc = c + acquires;
          if (nextc &lt; 0) // overflow
              throw new Error("Maximum lock count exceeded");
          setState(nextc);
          return true;
      }
      return false;
  }
  //é‡Šæ”¾é”
  protected final boolean tryRelease(int releases) {
      int c = getState() - releases;
      if (Thread.currentThread() != getExclusiveOwnerThread())
          throw new IllegalMonitorStateException();
      boolean free = false;
      if (c == 0) {
          free = true;
          setExclusiveOwnerThread(null);
      }
      setState(c);
      return free;
  }

  protected final boolean isHeldExclusively() {
      return getExclusiveOwnerThread() == Thread.currentThread();
  }

  final ConditionObject newCondition() {
      return new ConditionObject();
  }

  final Thread getOwner() {
      return getState() == 0 ? null : getExclusiveOwnerThread();
  }

  final int getHoldCount() {
      return isHeldExclusively() ? getState() : 0;
  }

  final boolean isLocked() {
      return getState() != 0;
  }

  private void readObject(java.io.ObjectInputStream s)
          throws java.io.IOException, ClassNotFoundException {
      s.defaultReadObject();
      setState(0); // reset to unlocked state
  }
}
</code></pre></div>    </div>
    <p>æˆ‘ä»¬å¯ä»¥çœ‹Syncæ˜¯ReentrantLockä¸€ä¸ªå†…éƒ¨ç±»ï¼Œå·²ç»å®ç°äº†nonfairTryAcquireæ–¹æ³•å’ŒtryReleaseæ–¹æ³•ï¼Œæˆ‘ä»¬ä¸€èˆ¬ä½¿ç”¨è¿‡ç¨‹ä¸­éƒ½æ˜¯åˆ†å…¬å¹³é”å’Œéå…¬å¹³é”ï¼Œå…¶å®å…¬å¹³é”å’Œéå…¬å¹³é”å°±æ˜¯ç»§æ‰¿äº†Syncç±»ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹ä¸‹ä»£ç </p>
  </li>
  <li>éå…¬å¹³é”
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static final class NonfairSync extends Sync {
  private static final long serialVersionUID = 7316153563782823691L;

  //éå…¬å¹³é”çš„è·å–é”
  final void lock() {
      if (compareAndSetState(0, 1))
          setExclusiveOwnerThread(Thread.currentThread());
      else
          acquire(1);
  }

  protected final boolean tryAcquire(int acquires) {
      return nonfairTryAcquire(acquires);
  }
}
</code></pre></div>    </div>
    <p>æˆ‘ä»¬å¯ä»¥çœ‹åˆ°éå…¬å¹³é”çš„è·å–é”è¿‡ç¨‹ä¼šå…ˆå°è¯•ä¸€ä¸‹è·å–é”ï¼Œå¦‚æœè·å–æˆåŠŸåˆ™ç›´æ¥è°ƒç”¨AQSé‡Œé¢çš„setExclusiveOwnerThreadæ–¹æ³•å°†exclusiveOwnerThreadæ”¹æˆå½“å‰çº¿ç¨‹ã€‚å¦‚æœå¤±è´¥åˆ™è°ƒç”¨AQSé‡Œé¢çš„acquireæ–¹æ³•è·å–é”ã€‚</p>
  </li>
  <li>å…¬å¹³é”
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static final class FairSync extends Sync {
  private static final long serialVersionUID = -3000897897090466540L;

  final void lock() {
      acquire(1);
  }

  /**
   * Fair version of tryAcquire.  Don't grant access unless
   * recursive call or no waiters or is first.
   */
  protected final boolean tryAcquire(int acquires) {
      final Thread current = Thread.currentThread();
      int c = getState();
      if (c == 0) {
          if (!hasQueuedPredecessors() &amp;&amp;
                  compareAndSetState(0, acquires)) {
              setExclusiveOwnerThread(current);
              return true;
          }
      }
      else if (current == getExclusiveOwnerThread()) {
          int nextc = c + acquires;
          if (nextc &lt; 0)
              throw new Error("Maximum lock count exceeded");
          setState(nextc);
          return true;
      }
      return false;
  }
}
</code></pre></div>    </div>
    <p>æˆ‘ä»¬å¯ä»¥çœ‹åˆ°å…¬å¹³é”çš„lockæ˜¯ç›´æ¥è°ƒç”¨AQSçš„acquireæ–¹æ³•ï¼Œä½†æ˜¯å‰é¢AQSæºç ä¸­æåˆ°ï¼Œä¼šå…ˆèµ°åˆ°å­ç±»å¤å†™çš„tryAcquireï¼Œé‚£ä¹ˆæ˜¯å¦‚ä½•åŒºåˆ†å…¬å¹³å’Œéå…¬å¹³çš„å‘¢ï¼Ÿå…¶å®å°±æ˜¯hasQueuedPredecessorsæ–¹æ³•ä¼šå…ˆåˆ¤æ–­ç­‰å¾…é˜Ÿåˆ—æ˜¯å¦æœ‰ç­‰å¾…çš„çº¿ç¨‹ï¼Œå¦‚æœæœ‰åˆ™å…ˆä¿è¯ç­‰å¾…çš„çº¿ç¨‹å…ˆè·å–é”ï¼Œä»è€Œå®ç°å…¬å¹³ã€‚</p>
  </li>
</ul>

<h1 id="å®ä¾‹">å®ä¾‹</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class ThreadPoolTest {
    private static ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat("Test-Thread").build();
    private static ExecutorService threadPool = new ThreadPoolExecutor(2,2,2, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(100), threadFactory,  new ThreadPoolExecutor.AbortPolicy());
    static ReentrantLock lock = new ReentrantLock(true);

    public static void main(String[] args) {

        try {
            Future future1 = threadPool.submit(() -&gt; printInfo("ç¬¬ä¸€ä¸ª"));
            Future future2 = threadPool.submit(() -&gt; printInfo("ç¬¬äºŒä¸ª"));
            finishThreads(future1, future2);
            System.out.println(threadPool);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void printInfo(String index) {
        lock.lock();
        try {
            if ("ç¬¬ä¸€ä¸ª".equalsIgnoreCase(index)) {
                Thread.sleep(5000);
            }
            System.out.println(Thread.currentThread().getName() + " " + index);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    private static void finishThreads(Future... futures) throws Exception {
        for (Future future : futures) {
            future.get();
        }
    }
}
</code></pre></div></div>
<p>ä¸Šé¢é€šè¿‡ReentrantLockå…¬å¹³é”å’ŒThreadPoolExecutorå®ç°äº†ä¸€ä¸ªé¡ºåºæ‰“å°çš„ç¨‹åºï¼Œå¤§å®¶å¯ä»¥è¿è¡Œè¯•è¯•ã€‚</p>
:ET