I"%<h1 id="类图">类图</h1>
<p>之前我们用反射创建一个类的对象可以通过该Class.newInstance()方法，但是可以发现这个方法只能构造包含无参构造函数的类，如果不包含则会报NoSuchMethodException异常，那么这个时候就需要用到Constructor类了。我们先看看Constructor类的类关系图
<img src="https://upload-images.jianshu.io/upload_images/9082703-dbde44c18920944b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类图" /></p>

<h1 id="源码精简版">源码（精简版）</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public final class Constructor&lt;T&gt; extends Executable {
    //用来存储ConstructorAccessor
    private Constructor&lt;T&gt;      root;
    //通过传入参数构造相对应的实例
    public T newInstance(Object ... initargs)
        throws InstantiationException, IllegalAccessException,
               IllegalArgumentException, InvocationTargetException
    {
        if (!override) {
            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
                Class&lt;?&gt; caller = Reflection.getCallerClass();
                checkAccess(caller, clazz, null, modifiers);
            }
        }
        if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0)
            throw new IllegalArgumentException("Cannot reflectively create enum objects");
        ConstructorAccessor ca = constructorAccessor;   // read volatile
        if (ca == null) {
            ca = acquireConstructorAccessor();
        }
        @SuppressWarnings("unchecked")
        T inst = (T) ca.newInstance(initargs);
        return inst;
    }
    //获取ConstructorAccessor 
    private ConstructorAccessor acquireConstructorAccessor() {
        // First check to see if one has been created yet, and take it
        // if so.
        ConstructorAccessor tmp = null;
        if (root != null) tmp = root.getConstructorAccessor();
        if (tmp != null) {
            constructorAccessor = tmp;
        } else {
            // Otherwise fabricate one and propagate it up to the root
            tmp = reflectionFactory.newConstructorAccessor(this);
            setConstructorAccessor(tmp);
        }

        return tmp;
    }

    // 直接返回root里的ConstructorAccessor
    ConstructorAccessor getConstructorAccessor() {
        return constructorAccessor;
    }

    // 给root赋值
    void setConstructorAccessor(ConstructorAccessor accessor) {
        constructorAccessor = accessor;
        // Propagate up
        if (root != null) {
            root.setConstructorAccessor(accessor);
        }
    }
}
</code></pre></div></div>
<p>由于其他方法基本都是复写的父类等，所以这边就只看了newInstance方法，可以通过reflectionFactory.newConstructorAccessor(this);方法获取不同的ConstructorAccessor并调用newInstance创建一个实例</p>

<h1 id="实例">实例</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class EmployeeDto {
    private int age;
    private String name;

    EmployeeDto() {
        this.age = 0;
        this.name = "default";
    }

    EmployeeDto(int age, String name) {
        this.age = age;
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public boolean isOlder(int tmpAge) {
        return age &gt; tmpAge;
    }

    @Override
    public String toString() {
        return "age:" + age + ",name:" + name;
    }
}

public class EmployeeConstructorTest {

    public static void main(String[] args) {
        try {
            Class clazz = Class.forName("reflect.EmployeeDto");
            Constructor[] constructors = clazz.getDeclaredConstructors();
            for (Constructor constructor : constructors) {
                if (constructor.getParameterCount() == 2) {
                    constructor.setAccessible(true);
                    EmployeeDto employeeDto = (EmployeeDto) constructor.newInstance(1,"test");
                    System.out.println(employeeDto);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre></div></div>
<p>EmployeeDto类有一个含参构造函数，然后main方法获取到该构造函数并newInstance创建一个实例并打印构建的对象，我们看看执行结果</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Connected to the target VM, address: '127.0.0.1:65499', transport: 'socket'
age:1,name:test
Disconnected from the target VM, address: '127.0.0.1:65499', transport: 'socket'
</code></pre></div></div>
<p>执行没有问题</p>
:ET