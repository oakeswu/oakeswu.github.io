I"ä-<h1 id="ä»€ä¹ˆæ˜¯ç±»åŠ è½½å™¨classloader">ä»€ä¹ˆæ˜¯ç±»åŠ è½½å™¨ï¼ˆClassLoaderï¼‰</h1>
<ul>
  <li>javaæ‰§è¡Œä¸€ä¸ªæ–¹æ³•ï¼Œä¼šå…ˆæŠŠjavaä»£ç ç¼–è¯‘æˆ.classæ–‡ä»¶ï¼ŒClassLoaderç±»å°±æ˜¯æ‰¾åˆ°å¯¹åº”çš„å·²ç¼–è¯‘çš„classå­—èŠ‚ç æ–‡ä»¶ï¼ŒåŠ è½½åˆ°è™šæ‹Ÿæœºå†…å­˜å¹¶åˆå§‹åŒ–ä¸€ä¸ªå®ä¾‹</li>
  <li>ClassLoaderå¯ä»¥åˆ†æˆBootStrap ClassLoaderï¼ŒExtClassLoaderï¼ŒAppClassLoaderï¼Œè‡ªå®šä¹‰ClassLoaderã€‚
1ï¼š Bootstrap ClassLoaderæ˜¯C++ç¼–å†™ï¼Œç”¨äºåŠ è½½\libç›®å½•ä¸‹çš„ç±»åº“ï¼Œå¹¶ä¸æ˜¯ClassLoaderçš„å­ç±»ï¼Œæ˜¯JVMçš„ä¸€éƒ¨åˆ†
2ï¼šExtClassLoaderè´Ÿè´£\lib\extç›®å½•ä¸‹çš„ç±»åº“ï¼Œæ˜¯ClassLoaderç±»çš„å­ç±»
3ï¼šAppClassLoaderè´Ÿè´£åŠ è½½classPathè·¯å¾„ä¸‹çš„ç±»åº“ï¼Œä¹Ÿæ˜¯ClassLoaderçš„å­ç±»
4:  ç±»çš„åŠ è½½æœºåˆ¶æ˜¯åŒäº²å§”æ´¾æœºåˆ¶ï¼ŒåŒäº²å§”æ´¾æœºåˆ¶å°±æ˜¯å¦‚æœä¸€ä¸ªClassLoaderæ”¶åˆ°ä¸€ä¸ªç±»éœ€è¦å®¶å®…çš„è¯·æ±‚ï¼Œå®ƒä¼šå…ˆæ£€æŸ¥è¯¥ç±»æ˜¯å¦å·²ç»åŠ è½½ï¼Œå¦‚æœæ²¡æœ‰åŠ è½½åˆ™ä¼šè¯·æ±‚ç»™parent ClassLoaderå»åŠ è½½ï¼Œæ­¤æ—¶å°±æ˜¯ä¸€ç§é€’å½’ï¼Œåªæœ‰å½“parent ClassLoaderæ— æ³•åŠ è½½è¯¥ç±»æ—¶æ‰ä¼šè‡ªå·±å°è¯•å»åŠ è½½ï¼Œè¿™ä¸ªç­‰ä¼šæˆ‘ä»¬å¯ä»¥é€šè¿‡æºç ä»”ç»†åˆ†æ</li>
</ul>

<h1 id="ä»£ç æ¡ˆä¾‹">ä»£ç æ¡ˆä¾‹</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class ClassLoaderTest {

    public static void main(String[] args) {
        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
        System.out.println("----");
        System.out.println(classLoader);
        ClassLoader extClassLoader = classLoader.getParent();
        System.out.println("----");
        System.out.println(extClassLoader);
        ClassLoader bootClassLoader = extClassLoader.getParent();
        System.out.println("----");
        System.out.println(bootClassLoader);
    }
}
</code></pre></div></div>
<p>ä¸Šé¢æˆ‘é€šè¿‡ä¸€æ®µä»£ç æµ‹è¯•æ‰“å°å‡ºClassLoaderçš„å±‚çº§å…³ç³»ï¼Œæˆ‘ä»¬å…ˆçœ‹ä¸‹æ‰§è¡Œç»“æœ</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Connected to the target VM, address: '127.0.0.1:65279', transport: 'socket'
Disconnected from the target VM, address: '127.0.0.1:65279', transport: 'socket'
----
sun.misc.Launcher$AppClassLoader@18b4aac2
----
sun.misc.Launcher$ExtClassLoader@69222c14
----
null

Process finished with exit code 0
</code></pre></div></div>
<p>æˆ‘ä»¬å¯ä»¥çœ‹åˆ°è¿™ä¸ªä¸‰ä¸ªåˆ†åˆ«æ˜¯AppClassLoader,ExtClassLoaderå’Œnullï¼Œè¿™é‡Œä¸ºå•¥ä¸æ˜¯Bootstrap ClassLoader,å› ä¸ºå‰é¢è¯´è¿‡Bootstrap ClassLoaderæ˜¯C++ç¼–å†™ï¼Œæ— æ³•é€šè¿‡è·å–å®ƒçš„javaå¯¹è±¡ï¼Œæ‰€ä»¥è¿™é‡Œè¾“å‡ºnull</p>

<h1 id="classloaderæºç ç²¾ç®€ç‰ˆåˆ†æ">ClassLoaderæºç ï¼ˆç²¾ç®€ç‰ˆï¼‰åˆ†æ</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/**
 * A class loader is an object that is responsible for loading classes. The
 * class &lt;tt&gt;ClassLoader&lt;/tt&gt; is an abstract class.  Given the &lt;a
 * href="#name"&gt;binary name&lt;/a&gt; of a class, a class loader should attempt to
 * locate or generate data that constitutes a definition for the class.  A
 * typical strategy is to transform the name into a file name and then read a
 * "class file" of that name from a file system.
 **/
public abstract class ClassLoader {
    // The parent class loader for delegation
    // åŒäº²åŠ è½½å™¨ï¼Œåœ¨æ„é€ å‡½æ•°ä¸­æŒ‡å®š
    private final ClassLoader parent;

    // Maps class name to the corresponding lock object when the current
    // class loader is parallel capable.
    // åˆ¤æ–­å½“å‰ç±»åŠ è½½å™¨æ˜¯å¦å¯èƒ½å‘ç”Ÿå¹¶å‘åŠ è½½
    private final ConcurrentHashMap&lt;String, Object&gt; parallelLockMap;

    /**
     * Encapsulates the set of parallel capable loader types.
     * è¯¥ç±»ç”¨æ¥æ³¨å†Œæˆ–éªŒè¯åŠ è½½å™¨ä¸ºå¹¶å‘åŠ è½½å™¨
     */
    private static class ParallelLoaders {
        private ParallelLoaders() {}

        // the set of parallel capable loader types
        private static final Set&lt;Class&lt;? extends ClassLoader&gt;&gt; loaderTypes =
            Collections.newSetFromMap(
                new WeakHashMap&lt;Class&lt;? extends ClassLoader&gt;, Boolean&gt;());
        static {
            synchronized (loaderTypes) { loaderTypes.add(ClassLoader.class); }
        }

        /**
         * Registers the given class loader type as parallel capabale.
         * Returns {@code true} is successfully registered; {@code false} if
         * loader's super class is not registered.
         */
        static boolean register(Class&lt;? extends ClassLoader&gt; c) {
            synchronized (loaderTypes) {
                if (loaderTypes.contains(c.getSuperclass())) {
                    // register the class loader as parallel capable
                    // if and only if all of its super classes are.
                    // Note: given current classloading sequence, if
                    // the immediate super class is parallel capable,
                    // all the super classes higher up must be too.
                    loaderTypes.add(c);
                    return true;
                } else {
                    return false;
                }
            }
        }

        /**
         * Returns {@code true} if the given class loader type is
         * registered as parallel capable.
         */
        static boolean isRegistered(Class&lt;? extends ClassLoader&gt; c) {
            synchronized (loaderTypes) {
                return loaderTypes.contains(c);
            }
        }
    }

    private ClassLoader(Void unused, ClassLoader parent) {
        this.parent = parent;
        if (ParallelLoaders.isRegistered(this.getClass())) {
            parallelLockMap = new ConcurrentHashMap&lt;&gt;();
            package2certs = new ConcurrentHashMap&lt;&gt;();
            domains =
                Collections.synchronizedSet(new HashSet&lt;ProtectionDomain&gt;());
            assertionLock = new Object();
        } else {
            // no finer-grained lock; lock on the classloader instance
            parallelLockMap = null;
            package2certs = new Hashtable&lt;&gt;();
            domains = new HashSet&lt;&gt;();
            assertionLock = this;
        }
    }
    
    /**
     * Loads the class with the specified &lt;a href="#name"&gt;binary name&lt;/a&gt;.
     * This method searches for classes in the same manner as the {@link
     * #loadClass(String, boolean)} method.  It is invoked by the Java virtual
     * machine to resolve class references.  Invoking this method is equivalent
     * to invoking {@link #loadClass(String, boolean) &lt;tt&gt;loadClass(name,
     * false)&lt;/tt&gt;}
      **/
    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {
        return loadClass(name, false);
    }
    
    /**
     * Loads the class with the specified &lt;a href="#name"&gt;binary name&lt;/a&gt;.  The
     * default implementation of this method searches for classes in the
     * following order:
     *
     * &lt;ol&gt;
     *
     *   &lt;li&gt;&lt;p&gt; Invoke {@link #findLoadedClass(String)} to check if the class
     *   has already been loaded.  &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; Invoke the {@link #loadClass(String) &lt;tt&gt;loadClass&lt;/tt&gt;} method
     *   on the parent class loader.  If the parent is &lt;tt&gt;null&lt;/tt&gt; the class
     *   loader built-in to the virtual machine is used, instead.  &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; Invoke the {@link #findClass(String)} method to find the
     *   class.  &lt;/p&gt;&lt;/li&gt;
     *
     * &lt;/ol&gt;
     *
     * &lt;p&gt; If the class was found using the above steps, and the
     * &lt;tt&gt;resolve&lt;/tt&gt; flag is true, this method will then invoke the {@link
     * #resolveClass(Class)} method on the resulting &lt;tt&gt;Class&lt;/tt&gt; object.
     **/
    protected Class&lt;?&gt; loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            Class&lt;?&gt; c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }
    
     /**
     * Returns the lock object for class loading operations.
     * For backward compatibility, the default implementation of this method
     * behaves as follows. If this ClassLoader object is registered as
     * parallel capable, the method returns a dedicated object associated
     * with the specified class name. Otherwise, the method returns this
     * ClassLoader object.
     * å¦‚æœåŠ è½½å™¨ä¸æ˜¯å¹¶å‘åŠ è½½å™¨ï¼Œç›´æ¥è¿”å›å½“å‰å¯¹è±¡ï¼Œå¦‚æœæ˜¯åˆ™æ–°åˆ›å»ºä¸€ä¸ªå¯¹è±¡ï¼Œæ³¨å†Œè¿›
        parallelLockMapå¹¶è¿”å›æ–°åˆ›å»ºçš„å¯¹è±¡
     **/
    protected Object getClassLoadingLock(String className) {
        Object lock = this;
        if (parallelLockMap != null) {
            Object newLock = new Object();
            lock = parallelLockMap.putIfAbsent(className, newLock);
            if (lock == null) {
                lock = newLock;
            }
        }
        return lock;
    }

    /**
     * Returns the class with the given &lt;a href="#name"&gt;binary name&lt;/a&gt; if this
     * loader has been recorded by the Java virtual machine as an initiating
     * loader of a class with that &lt;a href="#name"&gt;binary name&lt;/a&gt;.  Otherwise
     * &lt;tt&gt;null&lt;/tt&gt; is returned.
      **/
    protected final Class&lt;?&gt; findLoadedClass(String name) {
        if (!checkName(name))
            return null;
        return findLoadedClass0(name);
    }

    /**
     * Returns a class loaded by the bootstrap class loader;
     * or return null if not found.
     */
    private Class&lt;?&gt; findBootstrapClassOrNull(String name)
    {
        if (!checkName(name)) return null;

        return findBootstrapClass(name);
    }
}
</code></pre></div></div>
<p>ä¸Šé¢å°±æ˜¯ClassLoaderç±»çš„ç®€åŒ–ç‰ˆæºç ï¼Œæˆ‘ä»¬ä¸»è¦å…³æ³¨ä¸€ä¸‹å…¶ä¸­çš„loadClassæ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°é‡Œé¢æ˜¯ä¸€ä¸ªsynchronizedåŒæ­¥ä»£ç å—ï¼Œæ­¥éª¤å¦‚ä¸‹
1ï¼š å…ˆæ ¹æ®getClassLoadingLockæ–¹æ³•è·å–ç›¸åº”çš„é”
2ï¼š é€šè¿‡findLoadedClassæŸ¥çœ‹ç±»æ˜¯å¦å·²åŠ è½½ï¼Œå¦‚æœå·²ç»åŠ è½½åˆ™è¿”å›ï¼Œå¦‚æœæ²¡æœ‰åˆ™è¿›å…¥ä¸‹ä¸€æ­¥
3ï¼š é€šè¿‡parent ClassLoaderå»æ‰§è¡ŒloadClassæ–¹æ³•ï¼Œå¦‚æœparentä¸å­˜åœ¨åˆ™è°ƒç”¨findBootstrapClassOrNullæ–¹æ³•å»æŸ¥æ‰¾
4ï¼šé€šè¿‡parent ClassLoaderä»¥åŠBootstrap ClassLoaderéƒ½æ²¡æ‰¾åˆ°çš„è¯è°ƒç”¨findClassæ–¹æ³•æŸ¥æ‰¾</p>

<h1 id="æ€»ç»“">æ€»ç»“</h1>

<p>javaè‡ªå¸¦çš„ç±»åŠ è½½å™¨æœ‰ä¸‰ä¸ªï¼Œå®ƒä»¬å„è‡ªåŠ è½½ä¸åŒçš„åŒºåŸŸå†…å®¹ï¼Œä¹Ÿå®ç°äº†åŒäº²å§”æ´¾æœºåˆ¶ï¼Œå¢åŠ äº†å®‰å…¨æ€§ã€‚</p>
:ET