I"=<h1 id="èƒŒæ™¯">èƒŒæ™¯</h1>
<p>ExecutorServiceæ˜¯java.concurrentåŒ…ä¸‹é¢çš„ä¸€ä¸ªæ¥å£ï¼Œå¹¶ç»§æ‰¿äº†Executoræ¥å£ã€‚æ˜¯çº¿ç¨‹æ± å¸¸ä½¿ç”¨åˆ°çš„ç±»ï¼Œæ‰€ä»¥å‡†å¤‡å­¦ä¹ ä¸‹æ­¤ç±»</p>
<h1 id="executor">Executor</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/**
 * An object that executes submitted {@link Runnable} tasks. This
 * interface provides a way of decoupling task submission from the
 * mechanics of how each task will be run
 **/
public interface Executor {
    void execute(Runnable command);
}
</code></pre></div></div>
<p>Executoræ¥å£åªæœ‰ä¸€ä¸ªexecuteæ–¹æ³•ï¼Œä½†æ˜¯çœ‹ç±»ä¸Šé¢çš„æ³¨é‡Šè¯´æœ€å¤§çš„ä½œç”¨æ˜¯å¯¹ä»»åŠ¡æäº¤å’Œä»»åŠ¡æ‰§è¡Œè¿›è¡Œäº†è§£è€¦ï¼Œå¯ä»¥çœ‹ä¸‹å®˜æ–¹ç»™çš„ä¾‹å­</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class SerialExecutor implements Executor {
        final Queue&lt;Runnable&gt; tasks = new ArrayDeque&lt;Runnable&gt;();
        final Executor executor;
        Runnable active;

        SerialExecutor(Executor executor) {
            this.executor = executor;
        }

        public synchronized void execute(final Runnable r) {
            tasks.offer(new Runnable() {
                public void run() {
                    try {
                        r.run();
                    } finally {
                        scheduleNext();
                    }
                }
            });
            if (active == null) {
                scheduleNext();
            }
        }

        protected synchronized void scheduleNext() {
            if ((active = tasks.poll()) != null) {
                executor.execute(active);
            }
        }
    }}
</code></pre></div></div>
<p>åŸå§‹ä»»åŠ¡æäº¤æ–¹ç›´æ¥è°ƒç”¨new Thread(runnable).startæ‰§è¡Œï¼Œæ‰€ä»¥ä»»åŠ¡æäº¤å’Œè°ƒç”¨æ–¹ç›¸åŒã€‚è€Œä¾‹å­ä¸­ä»»åŠ¡æäº¤æ–¹åªéœ€è¦å°†ä»»åŠ¡æäº¤ç»™SerialExecutoræ‰§è¡Œå°±å¥½äº†ã€‚</p>
<h1 id="executorservice">ExecutorService</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public interface ExecutorService extends Executor {
    //æœ‰åºå…³é—­ä¹‹å‰æäº¤çš„ä»»åŠ¡ï¼Œä½†æ˜¯ä¸å†æ¥å—æ–°ä»»åŠ¡
    void shutdown();
    //åœæ­¢æ‰€æœ‰æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡ï¼Œå–æ¶ˆç­‰å¾…ä¸­çš„ä»»åŠ¡å¹¶è¿”å›ç­‰å¾…ä¸­çš„ä»»åŠ¡
    List&lt;Runnable&gt; shutdownNow();
    //æ˜¯å¦å·²ç»shut down,å½“è°ƒç”¨shutdownæˆ–è€…shutdownnowå°±ä¸ºtrue
    boolean isShutdown();
    //shutdownæˆ–shutdownnowä¸­æ‰€æœ‰å®Œæˆ
    boolean isTerminated
    //æäº¤ä¸€ä¸ªä»»åŠ¡å¹¶è¿”å›ä¸€ä¸ªFuture
    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);
    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);
    Future&lt;?&gt; submit(Runnable task);
    //æäº¤å¤šä¸ªä»»åŠ¡å¹¶è¿”å›å¤šä¸ªFuture    
    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
        throws InterruptedException;
    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,long timeout, TimeUnit unit) throws InterruptedException;
    //æäº¤å¤šä¸ªä»»åŠ¡å¹¶è¿”å›æ‰§è¡ŒæˆåŠŸçš„ä¸€ä¸ªä»»åŠ¡çš„ç»“æœ
    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
        throws InterruptedException, ExecutionException;
    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
</code></pre></div></div>
<p>æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ExecutorServiceç»§æ‰¿äº†Executoræ¥å£ï¼Œæ‰€ä»¥ExecutorServiceä¹Ÿå¯ä»¥ä½¿ç”¨executeï¼ˆRunnable runableï¼‰æ–¹æ³•</p>
:ET