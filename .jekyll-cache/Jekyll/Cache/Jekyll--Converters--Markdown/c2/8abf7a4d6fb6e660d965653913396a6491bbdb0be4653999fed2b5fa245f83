I"@<p><strong><em>本文参考《深入理解java虚拟机》</em></strong></p>
<h1 id="数据模型">数据模型</h1>
<p>Java中的内存区域是只JVM在执行Java程序时把它所管理的内存划分为若干个不同的数据区域，里面包括程序计数器，虚拟机栈，本地方法栈，堆和方法区（JDK1.8之后改成Metaspace）</p>
<ul>
  <li>程序计数器（线程私有）
1:程序计数器可以看作是当前线程所执行的字节码的行号指示器，字节码解释器根据计数器取到下一条需执行的字节码指令实现跳转循环等功能
2:唯一一个无OOM的区域</li>
  <li>虚拟机栈（线程私有）
1虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧，用于存储<strong>局部变量表，操作数栈，动态链接，方法出口等信息</strong>
2:每一个方法从调用直到执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。
3:局部变量表存放了编译期的各种基本数据类型，对象引用和returnAddress类型（指向了一条字节码指令的地址）。局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小此区域规定了两种异常，如果线程请求的栈深度大于虚拟机允许的深度将抛出<strong>StackOverflowError</strong>异常，如果虚拟机栈可以动态扩展，在扩展时无法申请到足够的内存将会抛出<strong>OutOfMemoryError</strong>异常。</li>
  <li>本地方法栈（线程私有）
1:与虚拟机栈作用非常相似，区别在于虚拟机栈为虚拟机执行Java方法服务，本地方法栈为Native方法服务</li>
  <li>堆（线程共享）
1:Java堆在虚拟机启动时创建，用于存放对象实例，几乎所有的对象实例和数组都要在堆上分配。
2:堆是垃圾回收器管理的主要区域。堆还可以根据垃圾回收器细分为<strong>Eden（新生代），From Survivor（新生代），To Survivor（新生代）），Old（老年代），Permanent（永久代，JDK1.8已经取消，存放于Metaspace）</strong>。
3:Java堆可以处于物理上不连续的内存空间中，只需要逻辑连续就可，一般可以通过-Xmx和-Xms控制大小分配，如果堆内没有内存完成实例分配且无法再扩展时会抛出OutOfMemoryError异常。</li>
  <li>方法区（线程共享）
1:jdk1.7之前都叫方法区，1.8之后改成Metaspace，方法区用于存储已被<strong>虚拟机加载的类信息，常量，静态变量即时编辑器编译后的代码等数据</strong>
2:运行时常量池是方法区的一部分，用于存放编译器生成的各种字面量和符号引用，<strong>由于1.8去掉了方法区，所以1.8之后的常量池移到了堆上面</strong></li>
</ul>

<h1 id="内存模型">内存模型</h1>
<p>由于cpu和内存读写速度相差较大，所以增加了cpu高速缓存区，将内存中常用的数据存放到高速缓存区中继而提高访问速度。那么数据交互的就从cpu与内存直接交换数据变成cpu先读取高速缓存区再读取内存。此时如果多线程访问就可能产生线程安全问题。熟悉多线程的都会听说过线程工作内存和主存，线程工作内存其实就是cpu寄存器和高速缓存的抽象描述，然后看下两种情形</p>
<ul>
  <li>单cpu多线程
 因为单cpu多线程是时间切片执行线程的，实际上线程也是依次执行，但是线程有可能会被中断导致多线程问题</li>
  <li>多cpu多线程
 多cpu存在多个高速缓存区，那样就有缓存不一致的问题，也会存在线程被中断问题
所以个人感觉内存模型描述的是cpu内存数据交互，此时会产生并发安全问题，不过Java也提供了很多解决方案，sychronized，volatile，cas等</li>
</ul>
:ET