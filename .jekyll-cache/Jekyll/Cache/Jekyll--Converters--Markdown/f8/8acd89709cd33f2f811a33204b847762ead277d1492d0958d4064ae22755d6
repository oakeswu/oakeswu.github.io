I"á7<h1 id="èƒŒæ™¯">èƒŒæ™¯</h1>
<p>Javaä¸­Listå’ŒMapæ˜¯å¸¸ç”¨çš„é›†åˆï¼Œä½†æ˜¯Listå’ŒMapéƒ½æ˜¯æ¥å£ç±»ï¼Œåœ¨å®ç°ç±»ä¸­æœ‰çº¿ç¨‹å®‰å…¨çš„ï¼Œä¹Ÿæœ‰çº¿ç¨‹ä¸å®‰å…¨çš„ï¼Œä»Šå¤©å°±æ¥æ•´ç†ä¸€ä¸‹ã€‚</p>

<h1 id="arraylistå’Œhashmap">ArrayListå’ŒHashMap</h1>
<p>ArrayListæ˜¯æœ‰ä¸€ä¸ªObject[]æ•°ç»„ç»„æˆçš„åˆ—è¡¨ï¼Œæˆ‘ä»¬å°±çœ‹ä¸‹addæ–¹æ³•çš„æºç </p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; 
           implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {
    /**
     * åœ¨listçš„å°¾éƒ¨å¢åŠ ä¸€ä¸ªå…ƒç´ 
     */
    public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }

     private void ensureCapacityInternal(int minCapacity) {
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
        }

        ensureExplicitCapacity(minCapacity);
    }

     private void ensureExplicitCapacity(int minCapacity) {
        modCount++;
        if (minCapacity - elementData.length &gt; 0)
            grow(minCapacity);
    }

    private void grow(int minCapacity) {
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
        if (newCapacity - minCapacity &lt; 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
}
</code></pre></div></div>
<p>æˆ‘ä»¬çœ‹åˆ°addæ–¹æ³•é‡Œé¢ä¼šå¯¹å…¨å±€å˜é‡sizeï¼ŒelementDataç­‰åšä¿®æ”¹ï¼Œä½†æ˜¯æ²¡æœ‰åŠ é”ï¼Œä¹Ÿå¯ä»¥çœ‹ä¸‹ArrayListä¸­å…¶ä»–æ–¹æ³•å‘ç°ä¹Ÿæ²¡æœ‰åŠ é”ï¼Œæ‰€ä»¥ArrayListå¤šçº¿ç¨‹ç¯å¢ƒä¸‹æœ‰å¹¶å‘é£é™©ï¼Œé‚£æˆ‘ä»¬å†æ¥çœ‹çœ‹1.8å½“ä¸­çš„HashMapçš„putæ–¹æ³•</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, Serializable {

    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
    
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        //å½“åˆ¤æ–­æ²¡æœ‰hashç¢°æ’æ—¶å€™å°±ç›´æ¥åŠ newNode
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node&lt;K,V&gt; e; K k;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
}
</code></pre></div></div>
<p>è¿™é‡Œå¯ä»¥çœ‹åˆ°HashMapçš„putæ–¹æ³•ä¹Ÿæ²¡æœ‰åŠ é”ï¼Œå¯ä»¥çœ‹åˆ°æˆ‘ç‰¹åœ°æ³¨é‡Šçš„åœ°æ–¹å½“ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶æ“ä½œçš„æ—¶å€™å¾ˆå¯èƒ½ä¼šå‘ç”Ÿæ•°æ®è¦†ç›–çš„é—®é¢˜ï¼Œè¿™é‡Œç‰¹åˆ«æ¨èä¸€ç¯‡æ–‡ç« ï¼Œå°†JDK1.7å’Œ1.8ä¸­HashMapçº¿ç¨‹ä¸å®‰å…¨çš„åœ°æ–¹ç®€å•çš„è¡¨è¿°å‡ºæ¥ï¼ˆ<a href="https://blog.csdn.net/swpu_ocean/article/details/88917958">JDK1.7å’ŒJDK1.8ä¸­HashMapä¸ºä»€ä¹ˆæ˜¯çº¿ç¨‹ä¸å®‰å…¨çš„</a>ï¼‰</p>

<h1 id="vectorå’Œhashtable">Vectorå’ŒHashtable</h1>
<p>æˆ‘ä»¬ä¹Ÿæ¥çœ‹ä¸‹Vectorçš„addæ–¹æ³•å’ŒHashtableä¸­çš„putæ–¹æ³•</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class Vector&lt;E&gt; extends AbstractList&lt;E&gt;
    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {
    
    public synchronized boolean add(E e) {
        modCount++;
        ensureCapacityHelper(elementCount + 1);
        elementData[elementCount++] = e;
        return true;
    }
}
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable {
    
    public synchronized V put(K key, V value) {
        // Make sure the value is not null
        if (value == null) {
            throw new NullPointerException();
        }

        // Makes sure the key is not already in the hashtable.
        Entry&lt;?,?&gt; tab[] = table;
        int hash = key.hashCode();
        int index = (hash &amp; 0x7FFFFFFF) % tab.length;
        @SuppressWarnings("unchecked")
        Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];
        for(; entry != null ; entry = entry.next) {
            if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) {
                V old = entry.value;
                entry.value = value;
                return old;
            }
        }

        addEntry(hash, key, value, index);
        return null;
    }
}
</code></pre></div></div>
<p>æˆ‘ä»¬å¯ä»¥çœ‹åˆ°Vectoré‡Œé¢å’ŒHashtableä¸­éƒ½å¢åŠ äº†synchronizedæ¥å®ç°çº¿ç¨‹å®‰å…¨ã€‚ä½†æ˜¯ç”±äºsynchronizedåœ¨ä»¥å‰ç®—ä¸€ä¸ªå¾ˆé‡çš„é”ï¼Œæ•ˆç‡ä¸é«˜ï¼Œæ‰€ä»¥æˆ‘ä»¬å¹³æ—¶ä¸€èˆ¬ç”¨çš„æ˜¯CopyOnWriteArrayListå’ŒConcurrentHashMapæ¥å®ç°çº¿ç¨‹å®‰å…¨</p>

<h1 id="copyonwritearraylistå’Œconcurrenthashmap">CopyOnWriteArrayListå’ŒConcurrentHashMap</h1>
<p>é‚£æˆ‘ä»¬æ¥ç®€å•çœ‹ä¸€ä¸‹CopyOnWriteArrayListçš„addæ–¹æ³•å’ŒConcurrentHashMapçš„putæ–¹æ³•</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class CopyOnWriteArrayList&lt;E&gt;
    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {
    
    public boolean add(E e) {
        //å¯é‡å…¥é”
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] elements = getArray();
            int len = elements.length;
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            newElements[len] = e;
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();
        }
    }
}
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
    implements ConcurrentMap&lt;K,V&gt;, Serializable {
    
    public V put(K key, V value) {
        return putVal(key, value, false);
    }

    final V putVal(K key, V value, boolean onlyIfAbsent) {
        if (key == null || value == null) throw new NullPointerException();
        int hash = spread(key.hashCode());
        int binCount = 0;
        for (Node&lt;K,V&gt;[] tab = table;;) {
            Node&lt;K,V&gt; f; int n, i, fh;
            if (tab == null || (n = tab.length) == 0)
                tab = initTable();
            else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
                if (casTabAt(tab, i, null,
                             new Node&lt;K,V&gt;(hash, key, value, null)))
                    break;                   // no lock when adding to empty bin
            }
            else if ((fh = f.hash) == MOVED)
                tab = helpTransfer(tab, f);
            else {
                V oldVal = null;
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        if (fh &gt;= 0) {
                            binCount = 1;
                            for (Node&lt;K,V&gt; e = f;; ++binCount) {
                                K ek;
                                if (e.hash == hash &amp;&amp;
                                    ((ek = e.key) == key ||
                                     (ek != null &amp;&amp; key.equals(ek)))) {
                                    oldVal = e.val;
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                }
                                Node&lt;K,V&gt; pred = e;
                                if ((e = e.next) == null) {
                                    pred.next = new Node&lt;K,V&gt;(hash, key,
                                                              value, null);
                                    break;
                                }
                            }
                        }
                        else if (f instanceof TreeBin) {
                            Node&lt;K,V&gt; p;
                            binCount = 2;
                            if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                           value)) != null) {
                                oldVal = p.val;
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                    }
                }
                if (binCount != 0) {
                    if (binCount &gt;= TREEIFY_THRESHOLD)
                        treeifyBin(tab, i);
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
        }
        addCount(1L, binCount);
        return null;
    }
}
</code></pre></div></div>
<p>æˆ‘ä»¬å¯ä»¥çœ‹åˆ°CopyOnWriteArrayListé‡Œé¢ä½¿ç”¨äº†ReentrantLocké”ï¼ŒConcurrentHashMapä½¿ç”¨äº†åˆ†æ®µé”æ¥å®ç°çº¿ç¨‹å®‰å…¨</p>

<h1 id="ä¾‹å­">ä¾‹å­</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class ListMapTest {
    private static final int size = 10000;

    public static void main(String[] args) throws Exception{
        SharedListAndMap sharedListAndMap = new SharedListAndMap();
        CountDownLatch countDownLatch = new CountDownLatch(size);
        sharedListAndMap.setCountDownLatch(countDownLatch);
        
        for (int i = 0; i &lt; size; i++) {
            Thread thread = new Thread(sharedListAndMap, "test"+i);
            thread.start();
        }
        countDownLatch.await();
        System.out.println("notSafeList:" + sharedListAndMap.getNotSafeList().size());
        System.out.println("safeList:" + sharedListAndMap.getSafeList().size());
        System.out.println("notSafeMap:" +sharedListAndMap.getNotSafeMap().size());
        System.out.println("safeMap:" +sharedListAndMap.getSafeMap().size());
    }

    private static class SharedListAndMap implements Runnable{
        private List&lt;String&gt; notSafeList = new ArrayList&lt;&gt;(size);
        private List&lt;String&gt; safeList = new CopyOnWriteArrayList&lt;&gt;();
        private Map&lt;String, String&gt; notSafeMap = new HashMap(size, 1);
        private Map&lt;String, String&gt; safeMap = new ConcurrentHashMap&lt;&gt;(size, 1);

        private CountDownLatch countDownLatch;
        public void setCountDownLatch(CountDownLatch countDownLatch) {
            this.countDownLatch = countDownLatch;
        }

        public List&lt;String&gt; getNotSafeList() {
            return notSafeList;
        }

        public List&lt;String&gt; getSafeList() {
            return safeList;
        }

        public Map&lt;String, String&gt; getNotSafeMap() {
            return notSafeMap;
        }

        public Map&lt;String, String&gt; getSafeMap() {
            return safeMap;
        }

        @Override
        public void run() {
            String threadName = Thread.currentThread().getName();
            notSafeList.add(threadName);
            safeList.add(threadName);
            notSafeMap.put(threadName, threadName);
            safeMap.put(threadName, threadName);
            countDownLatch.countDown();
        }
    }
}
</code></pre></div></div>
<p>ä¸Šé¢è´´äº†ä¸å°‘æºç æ¥è¯´æ˜ï¼Œæ­¤æ—¶æˆ‘ä»¬å†çœ‹ä¸€ä¸ªä»£ç å®ä¾‹æ¥éªŒè¯ä¸€ä¸‹ï¼Œè¿™é‡Œæ²¡æœ‰éªŒè¯Vectorï¼ŒHashtableï¼Œè¯»è€…å¯ä»¥è‡ªå·±å»éªŒè¯ã€‚æˆ‘ä»¬å¯ä»¥çœ‹ä¸‰æ¬¡çš„æ‰§è¡Œç»“æœ</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Connected to the target VM, address: '127.0.0.1:64887', transport: 'socket'
notSafeList:9999
safeList:10000
notSafeMap:9999
safeMap:10000
Disconnected from the target VM, address: '127.0.0.1:64887', transport: 'socket'
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Connected to the target VM, address: '127.0.0.1:49155', transport: 'socket'
notSafeList:9998
safeList:10000
notSafeMap:10000
safeMap:10000
Disconnected from the target VM, address: '127.0.0.1:49155', transport: 'socket'
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Connected to the target VM, address: '127.0.0.1:49174', transport: 'socket'
notSafeList:9985
safeList:10000
notSafeMap:10000
safeMap:10000
Disconnected from the target VM, address: '127.0.0.1:49174', transport: 'socket'
</code></pre></div></div>
<p>ä»ä¸Šé¢å°±å¯ä»¥çœ‹åˆ°ArrayListå’ŒHashMapæ˜¯ä¼šä¸¢å¤±æ•°æ®çš„ï¼Œè€ŒCopyOnWriteArrayListå’ŒConcurrentHashMapçº¿ç¨‹å®‰å…¨ã€‚å…¶å®é‡Œé¢è¿˜æœ‰å¾ˆå¤šå€¼å¾—æ¢ç©¶çš„ç‚¹ï¼Œè­¬å¦‚synchronizedçš„åŸç†ï¼ŒReentrantLockæ˜¯å•¥ï¼Œä»€ä¹ˆæ˜¯åˆ†æ®µé”ï¼ŒCountDownLatchæ˜¯ä»€ä¹ˆç­‰ç­‰ï¼Œæ‰€ä»¥æŠ€æœ¯æœ‰å¾ˆå¤šæ¢ç©¶çš„åœ°æ–¹ã€‚</p>
:ET