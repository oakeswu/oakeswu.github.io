I"[
<h1 id="背景">背景</h1>
<p>项目中经常会使用到redis对数据库进行减压或者分布式锁，以前只是对Redis的使用有一些学习，于是决定对Redis做一次完整的了解和学习。所以我们从官方文档开始。首先官网第一句话就是Redis is an open source (BSD licensed), <strong>in-memory data structure store</strong>, used as a database, cache and message broker。我们可以看到官方介绍数据是存放在内存中的，这也一定程度上能说明redis为啥访问速度可以超快。内存数据在断电之后是会消失的，但是我们发现Redis集群有时候因为故障再重启之后能恢复数据，这就是我们今天要学习的Redis持久化</p>

<h1 id="rdb">RDB</h1>
<p>RDB持久方式是指在指定的时间间隔对数据进行快照存储。Redis会将数据快照保存到dump.rdb的二进制文件中，可以设置Redis为满足”N秒内数据集至少有M个改动”时自动保存一次或者调用SAVE/BGSAVE手动进行数据保存。保存dump.rdb文件的步骤1 Redis调用forks拥有<strong>父进程和子进程</strong> 2 子进程将数据集写入到临时RDB文件中 3 当子进程完成对新RDB文件写入时，再替换掉老的RDB文件</p>
<ul>
  <li>
    <p>优点：
  1：RDB是一个紧凑的单一文件,很方便传送到另一个远端数据中心，非常适合用于快速的灾难恢复
  2：RDB在数据恢复的效率上比较好</p>
  </li>
  <li>
    <p>缺点
  1：由于是某个时间点存储数据，两次存储中间的数据有可能因为这一次故障而导致数据丢失
  2：由于需要fork子进程进行数据的持久化操作，当数据集很大的时候fork的过程会非常耗时，可能导致Redis在一些毫秒级内不能响应客户端的请求</p>
  </li>
</ul>

<h1 id="aof">AOF</h1>
<p>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据.AOF可以选择多种不同的fsync策略：无fsync，每秒fsync（默认），每次写的时候fsync。由于fsync是有后台线程进行处理的，主线程会尽力处理客户端请求，所以性能依旧不错，当RDB和AOF都开启，故障时会选择AOF恢复数据。</p>
<ul>
  <li>
    <p>优点
  1：由于默认会每秒fsync，所以出现故障也最多丢失一秒的数据
  2：当AOF文件体积过大时，Redis可以后台对AOF文件进行重写优化</p>
  </li>
  <li>
    <p>缺点
  1：由于AOF会记录下用户所有写操作，所以文件体积较大
  2：按照默认的每秒fsync方式，执行的频率较多</p>
  </li>
</ul>

:ET