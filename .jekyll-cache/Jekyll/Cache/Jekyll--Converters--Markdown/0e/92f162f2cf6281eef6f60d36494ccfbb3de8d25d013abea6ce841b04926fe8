I"ù<h1 id="èƒŒæ™¯">èƒŒæ™¯</h1>
<p>Executorsç±»å’Œä¸Šé¢çš„Executoræ¥å£çœ‹èµ·æ¥å¾ˆåƒï¼Œå°±å¢åŠ äº†ä¸€ä¸ªså­—ç¬¦ï¼Œä½†æ˜¯åŠŸèƒ½å®Œå…¨ä¸ä¸€æ ·ã€‚æˆ‘ä»¬å¯ä»¥çœ‹ä¸‹æºç çš„æ³¨é‡Šæ˜¯è¿™æ ·æè¿°çš„</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Factory</span> <span class="k">and</span> <span class="n">utility</span> <span class="n">methods</span> <span class="n">for</span> <span class="p">{@</span><span class="n">link</span> <span class="n">Executor</span><span class="p">},</span> <span class="p">{@</span><span class="n">link</span>
<span class="n">ExecutorService</span><span class="p">},</span> <span class="p">{@</span><span class="n">link</span> <span class="n">ScheduledExecutorService</span><span class="p">},</span> <span class="p">{@</span><span class="n">link</span>
<span class="n">ThreadFactory</span><span class="p">},</span> <span class="k">and</span> <span class="p">{@</span><span class="n">link</span> <span class="n">Callable</span><span class="p">}</span> <span class="n">classes</span> <span class="n">defined</span> <span class="k">in</span> <span class="n">this</span>
<span class="k">package</span>
</code></pre></div></div>
<p>ç¿»è¯‘ä¸€ä¸‹å°±æ˜¯Executorsç±»ä¸ºExecutorï¼ŒExecutorServiceï¼ŒScheduledExecutorServiceï¼ŒThreadFactoryï¼ŒCallableæä¾›å·¥å‚å’Œå®ç”¨æ–¹æ³•ï¼Œå¯ä»¥çœ‹çœ‹æºç å­¦ä¹ ä¸€ä¸‹</p>

<h1 id="æºç ç²¾ç®€ç‰ˆ">æºç ï¼ˆç²¾ç®€ç‰ˆï¼‰</h1>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class Executors {
    // åˆ›å»ºä¸€ä¸ªæŒ‡å®šä¸ªæ•°çº¿ç¨‹æ± 
    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&lt;Runnable&gt;());
    }

    //å¢åŠ ä¸€ä¸ªForkJoinPoolçš„çº¿ç¨‹æ± 
    public static ExecutorService newWorkStealingPool(int parallelism) {
        return new ForkJoinPool
            (parallelism,
             ForkJoinPool.defaultForkJoinWorkerThreadFactory,
             null, true);
    }
    public static ExecutorService newWorkStealingPool() {
        return new ForkJoinPool
            (Runtime.getRuntime().availableProcessors(),
             ForkJoinPool.defaultForkJoinWorkerThreadFactory,
             null, true);
    }

    // åˆ›å»ºåªåŒ…æ‹¬ä¸€ä¸ªçº¿ç¨‹çš„çº¿ç¨‹æ± 
    public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&lt;Runnable&gt;()));
    }

    // åˆ›å»ºä¸€ä¸ªå¯ç¼“å­˜çš„çº¿ç¨‹æ± 
    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&lt;Runnable&gt;());
    }

    // åˆ›å»ºä¸€ä¸ªè®¡åˆ’æ‰§è¡Œçš„çº¿ç¨‹
    public static ScheduledExecutorService newSingleThreadScheduledExecutor() {
        return new DelegatedScheduledExecutorService
            (new ScheduledThreadPoolExecutor(1));
    }

    //é»˜è®¤çš„çº¿ç¨‹å·¥å‚
    static class DefaultThreadFactory implements ThreadFactory {
        private static final AtomicInteger poolNumber = new AtomicInteger(1);
        private final ThreadGroup group;
        private final AtomicInteger threadNumber = new AtomicInteger(1);
        private final String namePrefix;

        DefaultThreadFactory() {
            SecurityManager s = System.getSecurityManager();
            group = (s != null) ? s.getThreadGroup() :
                                  Thread.currentThread().getThreadGroup();
            namePrefix = "pool-" +
                          poolNumber.getAndIncrement() +
                         "-thread-";
        }

        public Thread newThread(Runnable r) {
            Thread t = new Thread(group, r,
                                  namePrefix + threadNumber.getAndIncrement(),
                                  0);
            if (t.isDaemon())
                t.setDaemon(false);
            if (t.getPriority() != Thread.NORM_PRIORITY)
                t.setPriority(Thread.NORM_PRIORITY);
            return t;
        }
    }
}
</code></pre></div></div>
<p>æˆ‘ä»¬å¯ä»¥çœ‹åˆ°çº¿ç¨‹æ± éƒ½æ˜¯è¿”å›ä¸€ä¸ªThreadPoolExecutorå¯¹è±¡ï¼Œä¸Šé¢å¯ä»¥çœ‹åˆ°åˆ›å»ºäº†äº”ç§çº¿ç¨‹æ± ï¼Œç„¶åçº¿ç¨‹æ± æ‰§è¡Œæˆ‘ä»¬å¯ä»¥ç­‰çœ‹ä¸‹ThreadPoolExecutor</p>
:ET