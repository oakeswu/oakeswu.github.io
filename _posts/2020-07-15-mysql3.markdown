---
layout:     post
title:      "数据库事务"
subtitle:   ""
date:       2020-07-15
author:     "OakesWu"
header-img: "img/post-bg-2015.jpg"
tags:
    - Mysql
---

# 数据库事务是什么
我们这里借用百度百科的说明：数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。

# ACID
ACID是数据库事务的四大特性，是由数据库完成的。其中ACD通过日志来实现，因为日志记录了用户对数据库的所有操作，而I则是通过锁来实现。下面我们就来仔细的了解一下这四个属性
- A(atomicity) 原子性 
由于事物可有多个操作组成，原子性可以保证这些操作要么都执行成功，要么都失败。
- C(consistency) 一致性
几个并行执行的事务，起执行结果与串行执行的结果一致
- I(isolation) 隔离性
事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。可以保证多个事务对同一数据操作的安全性。
- D(durability) 持久性
当事务执行成功之后，系统保证事务的操作被永久的写入到数据库磁盘中。

# 四种隔离
![四种隔离级别](/img/doc/sql/sql3one.png)
我们可以看到数据库的隔离级别有四种，分别是读未提交(Read Uncommitted)，读已提交(Read Committed)，可重复读(Repeated Read)，串行化(Serializable)。**Mysql默认级别的是可重复读。SqlServer默认是读已提交。**我们看到表格上面的有脏读，不可重复读，幻读，我们来说说这是啥。
- 脏读
A事务修改了数据库，但是此时没有提交，而B事务读取到了A事务的修改就是脏读。
- 不可重复读
A事务在事务中需要多次读取同一条记录，而事务B对记录进行了修改并提交导致A在事务中读取的数据不一致
- 幻读
A事务在事务中当执行完全相同的查询，但是得到了不同的结果集。

我们上面分析了三种读取数据可能发生的问题，那我们现在就来看看四种隔离级别。
- Read Uncommited
我们看名字就能理解该级别是事务可以读取到其他没有提交的事务所做的数据修改。没有任何加锁，所以隔离级别最低。
- Read Committed
读已提交就是可以读到已提交的数据，解决了脏读的问题，但是没有解决不可重复读和幻读。
- Repeated Read
可重复读就是解决了不可重复读的问题，但是仍然可能存在幻读。
- Serializable
序列化通过将事务强制排序执行，解决幻读问题。