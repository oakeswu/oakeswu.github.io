---
layout:     post
title:      "JVM(四) -- GC回收算法"
subtitle:   ""
date:       2020-05-18
author:     "OakesWu"
header-img: "img/post-bg-2015.jpg"
tags:
    - JVM
---

***主要来源自阅读深入理解java虚拟机***
# 标记-清除
标记清除算法分为标记和清除两个阶段，首先标记出所有需要回收的对象，在标记完成后统计回收被标记的对象。但是该算法可能会产生大量不连续的内存碎片，碎片太多可能会导致后面程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发垃圾回收
# 复制
复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存用完了就将还存活的对象复制到另外一块上面，然后清理一下已使用的内存，这样在复制之后不用考虑内存碎片的情况，并提高了效率。所以HotSpot虚拟机将Survivor分为S0和S1
# 标记-整理
复制算法需额外增加内存空间用于复制，所以在标记-清除算法上升级一下可以变成标记-整理算法，标记过程仍然一样，但后续不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动然后再清理掉可回收对象
# 分代收集
Java堆分为新生代和老年代，这样可以根据各个年代的特点采用最适当的收集算法，在新生代中每次垃圾回收都只有少量存活，所以可以选用复制算法，用少量存活对象的复制成本就可以完成收集。老年代因为对象存活率高，没有额外空间进行分配担保，所以需要使用标记清除或标记整理